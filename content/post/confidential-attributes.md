---
title: "Exploring Confidential Attributes"
date: 2023-08-30T01:00:01+02:00
tags:
  - active-directory
  - windows
toc: true
showdate: true
---

I did not know about the existence of confidential attributes until I started looking into how LAPS works more in detail. As it turns out, the local administrator passwords are stored in an attribute that is added to the Computer objects when the feature is first enabled. Well sort of, this is an extremely high level description, find out more [here](https://adsecurity.org/?p=1790) (maybe a future post will cover LAPS).

We should know by now that storing passwords in AD attributes is a terrible idea, despite that I keep finding user passwords in their description all the time, so I asked myself: what keeps any domain user from just doing an LDAP query to obtain the clear text password straight out of the Computer object, like you would do with their description?

The answer is simple: there is a set of flags called *searchFlags* that can change some of the properties of an attribute, one of these marks them as confidential, which means they will be accessible by privileged users only. This is used to store LAPS passwords, BitLocker keys, Unix user credentials, and other sensitive data in specific attributes that normal users aren't able to access.

In order for a user to see a credential attribute they must possess the RIGHT_DS_CONTROL_ACCESS permission on the object containing the attribute, for example if user A has RIGHT_DS_CONTROL_ACCESS on *Computer* type objects they will be able to read LAPS passwords.

I thought this was a very interesting feature so I decided to dig deeper, this led me to learn new details about the AD schema, how security descriptors can be modified manually without the usual GUI permissions editor, and about the general structure of SDs and how it can be interpreted. This blog post shows what I have learned in this little experiment, the DirSync "attack" is also briefly covered since it can give attackers access to confidential attributes.

---

## **Creating Confidential Attributes**

To better explore this feature I am going to create a new confidential attribute, even if there are plenty by default I have fun discovering how to implement the features we exploit.

Every object in AD is of a specific **class** which defines exactly which attributes it supports. The structure of classes and attributes is stored in the Active Directory Schema, so if we want to create a custom attribute we must make a change to the schema.

First we register SchmMgmt.dll to add the Schema manager snap-in to *mmc*, as it isn't enabled by default:
```text
regsvr32 SchMgmt.dll
```

Then run *mmc.smc* and go to *add/remove snap-in*, select *Active Directory Schema*. Right click on *Attributes* -> *Create new attribute*, pick a name and description (i prefix mine with a *z* so it's easy to find at the bottom of the list):

![264d46f8181f95dee8ee648879dee1fb.png](/_resources/264d46f8181f95dee8ee648879dee1fb.png)

Syntax defines the data type of the attribute value, in this case I picked Unicode string because I want to store text in it. Multi-Valued is for attributes that contain more than one value much like an array, like *memberOf*.
The unique X500 OID must be generated by a script like the following, which outputs a new OID with Microsoft's own prefix:
```powershell
$Prefix="1.2.840.113556.1.8000.2554" 
$GUID=[System.Guid]::NewGuid().ToString() 
$Parts=@() 
$Parts+=[UInt64]::Parse($guid.SubString(0,4),"AllowHexSpecifier") 
$Parts+=[UInt64]::Parse($guid.SubString(4,4),"AllowHexSpecifier") 
$Parts+=[UInt64]::Parse($guid.SubString(9,4),"AllowHexSpecifier") 
$Parts+=[UInt64]::Parse($guid.SubString(14,4),"AllowHexSpecifier") 
$Parts+=[UInt64]::Parse($guid.SubString(19,4),"AllowHexSpecifier") 
$Parts+=[UInt64]::Parse($guid.SubString(24,6),"AllowHexSpecifier") 
$Parts+=[UInt64]::Parse($guid.SubString(30,6),"AllowHexSpecifier") 
$OID=[String]::Format("{0}.{1}.{2}.{3}.{4}.{5}.{6}.{7}",$prefix,$Parts[0],$Parts[1],$Parts[2],$Parts[3],$Parts[4],$Parts[5],$Parts[6]) 
$oid
```

![ac3b12872eb8e62c00da8c0cffc65f41.png](/_resources/ac3b12872eb8e62c00da8c0cffc65f41.png)

After clicking OK expand *Classes* and select the *user* class, go to *Attributes* and *Add*, my attribute is found at the bottom of the list, very conveniently:

![c314b1f35dc5983ae6a1ffcc903da831.png](/_resources/c314b1f35dc5983ae6a1ffcc903da831.png)

The new attribute is now part of the schema and available to *user* objects, but right now it is just like any other, we haven't made it confidential yet. To do that, we are going to have to change a specific attribute in the schema object of our attribute, because since everything in AD is described by objects, AD attributes themselves have their own objects.
We can access the schema using ADSI Edit: click on *Actions* -> *Connect To* -> select *Schema* as a well known Naming Context:

![e94b6adf5d4c4a407c511ed3141ed92c.png](/_resources/e94b6adf5d4c4a407c511ed3141ed92c.png)

After clicking OK we'll be connected to the schema, where we are going to need to look for the distinguished name of our attribute, again conveniently found at the bottom of the attributes list. Double click on it, and pick the *Attributes* tab. We are now in front of the list of attributes describing our newly created attribute object.

In the attributes list scroll down until we run into [searchFlags](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-ada3/f0b64fa8-6013-4e3c-aad3-ec881c11836d), which we are going to set to 128 to enable the CONFIDENTIAL flag (bit 7):

![e519dd55fefc34d448d62e0b0134ea33.png](/_resources/e519dd55fefc34d448d62e0b0134ea33.png)

*searchFlags* is a bitmask containing a few other settings, they have to do with ambiguous name resolution ([ANR](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/1a9177f4-0272-4ab8-aa22-3c3eafd39e4b)), indexing, and whether the attribute is part of the filtered attribute set ([FAS](https://learn.microsoft.com/en-us/windows/win32/ad/rodc-and-active-directory-schema)), which is the list of attributes that are never to be replicated to a RODC. By default the attribute is 0, meaning all the options are disabled, so all attributes are not seen as confidential and can be replicated to RODCs.
Click OK and you'll see the attribute is now marked as confidential:

![ec4a973c7ad624d2c943ca95bf31736d.png](/_resources/ec4a973c7ad624d2c943ca95bf31736d.png)

Confidential attributes can still be accessed, but only by security principals who have RIGHT_DS_READ_PROPERTY and RIGHT_DS_CONTROL_ACCESS permission on the specific attribute. By default domain and enterprise admins are allowed to access all confidential attributes, other users and groups can be assigned RIGHT_DS_CONTROL_ACCESS on one or more attributes so that they may read and modify them. Up next we are going to give a user permission to read zSecretUserIdentifier.

For the schema changes to take effect Active Directory Domain Services must be restarted, then we'll find zSecretUserIdentifier in the attribute editor tab of any user we pick form ADUC:

![b44432812b1ce60f3d27dd179958d7a4.png](/_resources/b44432812b1ce60f3d27dd179958d7a4.png)

Double clicking on the attribute lets us modify its value:

![2fc0a696e29e50bd4812cc1499f865e8.png](/_resources/2fc0a696e29e50bd4812cc1499f865e8.png)

As a domain admin we can now read the attribute on every user:

![1fc805a41b7c3cae4e353a2a8938383d.png](/_resources/1fc805a41b7c3cae4e353a2a8938383d.png)

Now if we wish to delegate other non privileged principals RIGHT_DS_CONTROL_ACCESS permissions to a resource we have two ways out of the box:
- GUI: ldp.exe
- cmd: dsacls.exe

ldp.exe is an LDAP client with a very useful feature to modify an object's security descriptor, it comes builtin in Windows Server. From the ldp.exe main window click *Connection* -> *Connect*, and type the name or address of the DC:

![b8cad3d1ad833d77995fcb342fb94135.png](/_resources/b8cad3d1ad833d77995fcb342fb94135.png)

The output should show how the client connected to the LDAP server's RootDSE:

![df45dda389412093494356b7b61fca9f.png](/_resources/df45dda389412093494356b7b61fca9f.png)

To fully connect using our domain admin account go to *Connection* -> *Bind*, and *Bind as currently logged on user*:

![0b8b1859f4cf15d96948d90707326d90.png](/_resources/0b8b1859f4cf15d96948d90707326d90.png)

The output reflects we are connected as the domain admin:

![9dcfe0dd2e0c948abb3a8453afa013f9.png](/_resources/9dcfe0dd2e0c948abb3a8453afa013f9.png)

Now to actually see the hierarchy of LDAP objects go to *View* -> *Tree*, select the DN of the domain root as *BaseDN*:

![4d1af8075caf5ce2abddb95641f37694.png](/_resources/4d1af8075caf5ce2abddb95641f37694.png)

The LDAP tree can now be explored, go pick the OU that contains the users who will make use of the attribute, like the default *Users* OU, right click on it -> *Advanced* -> *Security Descriptor*:

![b088fc9feaa64c8aee64aba163638dce.png](/_resources/b088fc9feaa64c8aee64aba163638dce.png)

A window asking for a DN will open:

![1cd6d35eee1c8f87f0e824e3b0d204ad.png](/_resources/1cd6d35eee1c8f87f0e824e3b0d204ad.png)

We can tick the second box to view a textual representation of the object's security descriptor if we are curious to see what the structure looks like, and it's interesting going through it:

![69e58a57a4175a8e54419722c08f30af.png](/_resources/69e58a57a4175a8e54419722c08f30af.png)

The SACL box on the left on the other hand allows us to view the security access control list of this object, so the ACL detailing what operations will be audited in the Windows logs. We are not interested in the SACL so leave both boxes unchecked and click OK, the security descriptor editor opens:

![aed8b64ef3ca677fbb883117f3ce86ce.png](/_resources/aed8b64ef3ca677fbb883117f3ce86ce.png)

We are interested in adding a new ACE to the ACL, so click *Add* :

![cd60136b2d51bab5d4093d3d64c82600.png](/_resources/cd60136b2d51bab5d4093d3d64c82600.png)

- *Trustee* should contain the SamAccountName of the security principal to be delegated
- *Access mask* should have **Read permissions** and **Control access checked** (**write property** too if we want the users to modify the attributes and not just read them)
- *ACE flags* should have **Inherit** checked
- *Object type* is set to the confidential attribute the principal will be able to read
- *Inherited object type* is set to **user**

Click on OK, the DACL should now appear as such:

![f024c3f32c8d8ad8fcd657ff81fc90c3.png](/_resources/f024c3f32c8d8ad8fcd657ff81fc90c3.png)

Then click on *Update* making sure the *DACL* option next to it is checked, the other boxes should stay unchecked unless you made other modifications to the security descriptor.
Now if we want we can do a text dump of the OU's SD to see the textual representation of the new ACE:

![591a721d48c38dde013f08f997f8a2ec.png](/_resources/591a721d48c38dde013f08f997f8a2ec.png)

Time to check these new permissions. Here's a normal user account, *tantani*, trying to read the attribute of its own account:

![9f6205de9d0b9223a3f296a33df18433.png](/_resources/9f6205de9d0b9223a3f296a33df18433.png)

The attribute does not appear at all in the output, if it was unset and the user had the required permissions to access it then the attribute name would appear, with an empty line after the colon.

On the other hand here is the delegated user, aarmani, trying to read the same user's attribute:

![6e3c0eac9bffbe921a8f65ac302dace1.png](/_resources/6e3c0eac9bffbe921a8f65ac302dace1.png)

We have successfully added a confidential attribute in our AD!

---

## **Enumerating Confidential Attributes**

If we want to query the AD schema to look for all attributes that are marked as confidential we can use an LDAP filter with the *Get-ADObject* cmdlet by setting the schema's distinguished name as the baseDN.

To do that first we find the *SchemaNamingContext* with *Get-ADRootDSE*:

![99834b5293a43e2f666c8fbd71e7288d.png](/_resources/99834b5293a43e2f666c8fbd71e7288d.png)

Since ultimately we want to automate the enumeration process I place the interested attribute into a variable:
```powershell
$schema = (Get-ADRootDSE).SchemaNamingContext
```

This is what the attribute object's own attributes look like (found with ANR query?):

![6362af4d582019c070bbc94569b80be9.png](/_resources/6362af4d582019c070bbc94569b80be9.png)

The attributes we may be interested in are: DistinguishedName, Name, adminDescription, and searchFlags, this last one actually containing the CONFIDENTIAL flag so it will be used within the filter.

Microsoft provides an [OID](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/4e638665-f466-4597-93c4-12f2ebfabab5) specifically for bitwise AND checks on flags: 1.2.840.113556.1.4.803, this will be used to filter out all attributes that do not have a *searchFlags* attribute with the CONFIDENTIAL bit set.

The resulting command to obtain all confidential attributes is:
```powershell
Get-ADObject -LDAPFilter "(&(objectClass=attributeSchema)(searchFlags:1.2.840.113556.1.4.803:=128))" -SearchBase (Get-ADRootDSE).SchemaNamingContext -Properties * | select adminDisplayName,adminDescription | fl
```

This is useful because any domain user can query the schema, so users don't need to be able to read the attribute's values in order to check which confidential attributes exist in the schema.

![e00bc08c4740d862c491251d66f2d0e9.png](/_resources/e00bc08c4740d862c491251d66f2d0e9.png)

Interestingly enough this let me discover the *unixUserPassword* attribute too, which is worth looking into at some point. But of course at the end of the list our custom attribute appears as well:

![be5b456b9df4d602be9c357b118a9de4.png](/_resources/be5b456b9df4d602be9c357b118a9de4.png)

Now to find out what users have access to what attributes, dsacls.exe can be used to read any object's DACL, so we can specify the DN of the *Users* OU and get all of the ACEs in its DACL:

![a2c800ee13af63b8efad6388b9a16ea7.png](/_resources/a2c800ee13af63b8efad6388b9a16ea7.png)

Scrolling down further we eventually find the ACE relative to the custom attribute:

![ec31e400f8275a40e73396a71ded63c8.png](/_resources/ec31e400f8275a40e73396a71ded63c8.png)

So with a bit of PowerShell we can just obtain the list of principals who are given permissions explicitely to the attribute, in this case *armani* can only read other users' *zSecretUserIdentifier*:

![4956e341ba6c56be94d19243db5496bf.png](/_resources/4956e341ba6c56be94d19243db5496bf.png)




## **Automatic Enumeration: Declassify.ps1**

Declassify is a very small and basic PowerShell script that lists confidential attributes of user and computer objects and finds if any principals have non-default permissions. It misses quite a few things as of now, it's very WIP and I'll put more work into it when I can to make it more effective, right now it's just an experimental little thing to quickly see if there are any custom confidential attributes in the domain, and if that wasn't enough it has to be run on a DC because it relies on the output of dsacls.exe, which only gets installed with AD DS on domain controllers.

List every confidential attribute:

![3c5d23a811640b96d423a1c6bee3f13c.png](/_resources/3c5d23a811640b96d423a1c6bee3f13c.png)
Find non-standard permissions to confidential attributes:

![11f4751960b20ef5fa971e8564b0c89f.png](/_resources/11f4751960b20ef5fa971e8564b0c89f.png)

So far it only finds explicit permissions, not inherited ones. For example it doesn't find users who have CONTROL ACCESS over the root of the domain and inherit it to all children objects.

This is the full script if anyone wants to play with it.
```powershell
param ([switch]$List = $False)

$attributes = Get-ADObject -LDAPFilter "(&(objectClass=attributeSchema)(searchFlags:1.2.840.113556.1.4.803:=128))" -SearchBase (Get-ADRootDSE).SchemaNamingContext | foreach {$_.Name}

if ($list -eq $true)
{
    Write-Host "[ALL CONFIDENTIAL ATTRIBUTES]"
    foreach ($attr in $attributes)
    {
        Write-Host $attr
    }
    Exit
}

$domainOU = Get-ADDomain | foreach {$_.DistinguishedName}
$usersContainer = "CN=Users," + $domainOU
$computersContainer = "CN=Computers," + $domainOU

$output = dsacls $usersContainer
Write-Host "[USER ATTRIBUTES]"
foreach ($attr in $attributes)
{
    $ace = $output | Select-String $attr
    if ($ace -like "*SPECIAL ACCESS*")
    {
        if ($ace -match 'Allow ([^\s]+)\s')
        {
            Write-Host $Matches[1] "--[READ]-->"$attr
        }
    }
}

$output = dsacls $computersContainer
Write-Host "[COMPUTER ATTRIBUTES]"
foreach ($attr in $attributes)
{
    $ace = $output | Select-String $attr
    if ($ace -like "*SPECIAL ACCESS*")
    {
        if ($ace -match 'Allow ([^\s]+)\s')
        {
            Write-Host $Matches[1] "--[READ]-->"$attr
        }
    }
}
```


---

## **DirSync**

[DirSync](https://simondotsh.com/infosec/2022/07/11/dirsync.html) is an LDAP extended control introduced by Microsoft, it should be used by domain controllers during replication to request all the data that has changed since the last DirSync operation. The data that can be replicated with DirSync includes confidential attributes, so it is a very good way to access them. These are the permissions required to do a DirSync operation:
- DS-Replication-Get-Changes
- DS-Replication-Get-Changes-In-Filtered-Set

Basically the DCSync permissions minus DS-Replication-Get-Changes-All, so if you can DCSync the domain you can also DirSync it, but if a user is missing DS-Replication-Get-Changes-All they won't be able to DCSync, so forget about grabbing those domain admin hashes.

Take the user *tantani*, they have DS-Replicaiton-Get-Changes on the domain:

![bc3397a62fb1325f9e3318ab6cb8a43b.png](/_resources/bc3397a62fb1325f9e3318ab6cb8a43b.png)

Here *tantani* used the DirSync PoC linked above to successfully access the zSecretUserIdentifier attribute despite not having explicit permissions to read it, an access attempt with Get-ADUser is also tried to prove the user can't normally see the attribute, which isn't returned at all due to insufficient permissions:

![f54dbc8f47eed54a751edbc17b54941b.png](/_resources/f54dbc8f47eed54a751edbc17b54941b.png)

Most attributes can be retrieved as long as DS-Replication-Get-Changes is assigned to a user, DS-Replication-Get-Changes-In-Filtered-Set is useful to access attributes that are part of the FAS like LAPS passwords, found in the *ms-Mcs-AdmPwd* attribute of the computer object.

---

## **Interesting Confidential Attributes**

**ms-Mcs-AdmPwd**

Only present in computer accounts when LAPS is enabled, it will store the clear-text password for the computer's default administrator

**msDS-ManagedPassword**

Only exists on objects of class *msDS-GroupManagedServiceAccount*, which are group-managed service accounts (gMSA). This attribute is a BLOB (Binary Large Object) containing the account's password (a post on gMSA may come in the future)

**UnixUserPassword**

It will sometimes contain the SHA1 hash of POSIX user accounts when the domain has AD-joined \*nix computers. In past Windows versions this role was covered by either *userPassword* or *msSFU30Password*, so these attributes may still be present in domains that have existed on DCs running Windows 2000 or Windows Server 2003

**ms-Kds-RootKeyData**

This and the other attributes starting with *ms-Kds* which can be seen in the output of the script above are used by the Key Distirbution Service (KDS) for the generation of gMSA passwords. While the gMSA credentials are rotated automatically (the whole point of gMSA) the attributes used to generate new passwords are not updated until an admin does it manually, so if an attacker gets access to these attributes they will be able to predict the future passwords of managed service accounts. This attack is known as [golden gMSA](https://www.semperis.com/blog/golden-gmsa-attack/) and the gMSA passwords can be generated completely offline

**ms-PKI-DPAPIMasterKeys**

A user-specific symmetric key used to encrypt and decrypt [roamed credentials](https://techcommunity.microsoft.com/t5/ask-the-directory-services-team/certs-on-wheels-understanding-credential-roaming/ba-p/395897) using DPAPI, it is stored in encrypted format and its decryption requires either the user's password (or SHA1 hash) or the domain backup key, retrievable only by administrators

**ms-PKI-AccountCredentials** 

It contains user secrets that are synced with credential roaming, including private keys, certificates, and passwords. These are decrypted with the key found in *ms-PKI-DPAPIMasterKeys*

**ms-FVE-RecoveryPassword**

BitLocker key required to recover a disk partition protected by Full Volume Encryption (FVE)

---

## **Conclusion**

Confidential attributes are used to store information that should remain, well... confidential. For that reason the permissions required to access these should be assigned very carefully and one should be mindful of the replication permissions as well, as they will be able to read every confidential attribute regardless of their explicit permissions.

The very nature of these attributes means unauthorized access could be dangerous based on what they are used for, for some like *UnixUserPassword* and *ms-Mcs-AdmPwd* it could mean the compromise of many users and computers that could easily put them on the right path to domain escalation.

**References**
- https://learn.microsoft.com/en-US/troubleshoot/windows-server/windows-security/mark-attribute-as-confidential
- https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/e6685d31-5d87-42d0-8a5f-e55d337f47cd
- https://simondotsh.com/infosec/2022/07/11/dirsync.html
- https://cqureacademy.com/blog/extracting-roamed-private-keys
- https://www.ibm.com/docs/en/aix/7.2?topic=servers-active-directory-password-attribute-selection
